#!/usr/bin/env python3
import sys
import re
import os
import argparse

# =============================================================================
# CONFIGURATION: Port Mappings for SAED14 SRAMs
# =============================================================================
PINS = {
    "CLK": "CE",
    "CS_N": "CSB",  # Chip Select (Active Low)
    "WE_N": "WEB",  # Write Enable (Active Low)
    "OE_N": "OEB",  # Output Enable (Active Low)
    "ADDR": "A",
    "DIN":  "I",
    "DOUT": "O"
}

def parse_lib_file(lib_path):
    """Scans a Synopsys .lib file for memory cells."""
    print(f"[Auto-Mem] Scanning library: {lib_path}")

    # 1. generic_regex: Matches ANY cell definition to debug what is in the file
    #    Looks for: cell ( NAME )
    generic_regex = re.compile(r"^\s*cell\s*\(\s*(\w+)\s*\)")

    # 2. sram_regex: specifically looks for SRAM patterns
    #    Matches: SRAM1RW1024x32, ram_2rw_128x64, etc. (Case Insensitive)
    #    Group 1: Full Name
    #    Group 2: Type (1RW or 2RW)
    #    Group 3: Depth
    #    Group 4: Width
    sram_regex = re.compile(r"(\w*(1rw|2rw)(\d+)x(\d+)\w*)", re.IGNORECASE)

    memories = []
    cell_count = 0

    try:
        with open(lib_path, 'r') as f:
            for line in f:
                # Check for any cell definition
                gen_match = generic_regex.search(line)
                if gen_match:
                    cell_name = gen_match.group(1)
                    cell_count += 1

                    # Check if it is an SRAM
                    sram_match = sram_regex.search(cell_name)
                    if sram_match:
                        memories.append({
                            "name":  sram_match.group(1),
                            "type":  sram_match.group(2).upper(), # Normalize to 1RW/2RW
                            "depth": int(sram_match.group(3)),
                            "width": int(sram_match.group(4))
                        })
                    else:
                        # Print first 5 non-matching cells to help debug
                        if cell_count <= 5:
                            print(f"[Debug] Found non-SRAM cell: {cell_name}")

    except FileNotFoundError:
        print(f"[Error] Library file not found: {lib_path}")
        sys.exit(1)

    print(f"[Auto-Mem] Scanned {cell_count} total cells.")
    print(f"[Auto-Mem] Identified {len(memories)} valid SRAM macros.")

    if len(memories) == 0 and cell_count > 0:
        print("[Error] Cells were found, but none matched the SRAM naming convention (e.g. SRAM1RW... or ram_1rw...).")
        print("Please check the '[Debug]' output above to see the actual cell names.")

    return memories

def generate_sp_wrapper(memories, output_dir):
    filename = os.path.join(output_dir, "VX_sp_ram_asic.v")
    sp_mems = [m for m in memories if m['type'] == '1RW']
    sp_mems.sort(key=lambda x: (x['width'], x['depth']))

    with open(filename, 'w') as f:
        f.write("""// AUTOMATICALLY GENERATED BY gen_srams.py
(* keep_hierarchy = "yes" *)
module VX_sp_ram_asic #(
    parameter DATAW = 32,
    parameter SIZE  = 1024,
    parameter WRENW = 1,
    parameter ADDRW = $clog2(SIZE)
) (
    input  wire             clk,
    input  wire             reset,
    input  wire             read,
    input  wire             write,
    input  wire [WRENW-1:0] wren,
    input  wire [ADDRW-1:0] addr,
    input  wire [DATAW-1:0] wdata,
    output wire [DATAW-1:0] rdata
);
    wire write_n = ~write;
    wire read_n  = ~read;
    wire cs_n    = 1'b0;

    generate
""")

        first = True
        for m in sp_mems:
            prefix = "if" if first else "else if"
            first = False

            phy_addr_w = max(1, (m['depth'] - 1).bit_length())

            # Explicit string concatenation
            pad_calc = f"{phy_addr_w} - ADDRW"
            pad_expr = "{ {" + pad_calc + "{1'b0}}, addr }"

            f.write(f"""
        {prefix} (DATAW == {m['width']} && SIZE <= {m['depth']}) begin : g_{m['name']}
            wire [{phy_addr_w-1}:0] internal_addr;

            // If requested size is smaller than physical macro, pad MSBs with 0
            assign internal_addr = (ADDRW < {phy_addr_w}) ?
                                   {pad_expr} :
                                   addr[{phy_addr_w-1}:0];

            {m['name']} u_mem (
                .{PINS['CLK']}  ( clk ),
                .{PINS['CS_N']} ( cs_n ),
                .{PINS['WE_N']} ( write_n ),
                .{PINS['OE_N']} ( read_n ),
                .{PINS['ADDR']} ( internal_addr ),
                .{PINS['DIN']}  ( wdata ),
                .{PINS['DOUT']} ( rdata )
            );
        end""")

        f.write("""
        else begin
            initial begin
                $error("No suitable Single Port SRAM found for W=%d D=%d", DATAW, SIZE);
            end
        end
    endgenerate
endmodule
""")
    print(f"[Auto-Mem] Generated {filename}")

def generate_dp_wrapper(memories, output_dir):
    filename = os.path.join(output_dir, "VX_dp_ram_asic.v")
    dp_mems = [m for m in memories if m['type'] == '2RW']
    dp_mems.sort(key=lambda x: (x['width'], x['depth']))

    with open(filename, 'w') as f:
        f.write("""// AUTOMATICALLY GENERATED BY gen_srams.py
(* keep_hierarchy = "yes" *)
module VX_dp_ram_asic #(
    parameter DATAW = 32,
    parameter SIZE  = 1024,
    parameter WRENW = 1,
    parameter ADDRW = $clog2(SIZE)
) (
    input  wire             clk,
    input  wire             reset,
    input  wire             read,
    input  wire             write,
    input  wire [WRENW-1:0] wren,
    input  wire [ADDRW-1:0] waddr,
    input  wire [DATAW-1:0] wdata,
    input  wire [ADDRW-1:0] raddr,
    output wire [DATAW-1:0] rdata
);
    wire we_a_n = ~write;
    wire ce_b_n = ~read;

    generate
""")

        first = True
        for m in dp_mems:
            prefix = "if" if first else "else if"
            first = False
            phy_addr_w = max(1, (m['depth'] - 1).bit_length())

            pad_calc = f"{phy_addr_w} - ADDRW"
            pad_waddr = "{ {" + pad_calc + "{1'b0}}, waddr }"
            pad_raddr = "{ {" + pad_calc + "{1'b0}}, raddr }"

            f.write(f"""
        {prefix} (DATAW == {m['width']} && SIZE <= {m['depth']}) begin : g_{m['name']}
            wire [{phy_addr_w-1}:0] a1_addr;
            assign a1_addr = (ADDRW < {phy_addr_w}) ? {pad_waddr} : waddr[{phy_addr_w-1}:0];

            wire [{phy_addr_w-1}:0] a2_addr;
            assign a2_addr = (ADDRW < {phy_addr_w}) ? {pad_raddr} : raddr[{phy_addr_w-1}:0];

            {m['name']} u_mem (
                .CE1  ( clk ),
                .CSB1 ( 1'b0 ),
                .WEB1 ( we_a_n ),
                .OEB1 ( 1'b1 ),
                .A1   ( a1_addr ),
                .I1   ( wdata ),
                .O1   ( ),

                .CE2  ( clk ),
                .CSB2 ( 1'b0 ),
                .WEB2 ( 1'b1 ),
                .OEB2 ( ce_b_n ),
                .A2   ( a2_addr ),
                .I2   ( {m['width']}'b0 ),
                .O2   ( rdata )
            );
        end""")

        f.write("""
        else begin
            initial begin
                $error("No suitable Dual Port SRAM found for W=%d D=%d", DATAW, SIZE);
            end
        end
    endgenerate
endmodule
""")
    print(f"[Auto-Mem] Generated {filename}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("lib_file")
    parser.add_argument("out_dir")
    args = parser.parse_args()

    if not os.path.exists(args.out_dir):
        os.makedirs(args.out_dir)

    mems = parse_lib_file(args.lib_file)

    if not mems:
        print("[Error] No memories found. Check lib file or regex.")
        sys.exit(1)

    generate_sp_wrapper(mems, args.out_dir)
    generate_dp_wrapper(mems, args.out_dir)