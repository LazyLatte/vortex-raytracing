#!/usr/bin/env python3

# Copyright Â© 2019-2023
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import re
import os
import argparse

# =============================================================================
# CONFIGURATION: Port Mappings
# =============================================================================
PINS = {
    "CLK": "CE",
    "CS_N": "CSB",  # Chip Select (Active Low)
    "WE_N": "WEB",  # Write Enable (Active Low)
    "OE_N": "OEB",  # Output Enable (Active Low)
    "ADDR": "A",
    "DIN":  "I",
    "DOUT": "O"
}

def parse_lib_file(lib_path):
    """Scans a Synopsys .lib file for memory cells."""
    print(f"[Auto-Mem] Scanning library: {lib_path}")

    # 1. Generic Match: Finds any cell to help with debugging
    generic_regex = re.compile(r"^\s*cell\s*\(\s*(\w+)\s*\)")

    # 2. Standard Regex (SAED14 / Generic)
    #    Matches: SRAM1RW1024x32, ram_2rw_128x64
    #    Expects explicit '1rw' or '2rw' in the name
    std_regex = re.compile(r"(\w*(1rw|2rw)(\d+)x(\d+)\w*)", re.IGNORECASE)

    # 3. ASAP7 Regex (Banked Format)
    #    Matches: srambank_128x4x32_6t122
    #    Format: srambank_<ROWS>x<BANKS>x<WIDTH>_<TECH>
    asap7_regex = re.compile(r"srambank_(\d+)x(\d+)x(\d+)_\w*", re.IGNORECASE)

    memories = []
    cell_count = 0

    try:
        with open(lib_path, 'r') as f:
            for line in f:
                # Check for any cell definition
                gen_match = generic_regex.search(line)
                if gen_match:
                    cell_name = gen_match.group(1)
                    cell_count += 1

                    # --- Check 1: Standard Format ---
                    std_match = std_regex.search(cell_name)
                    if std_match:
                        memories.append({
                            "name":  std_match.group(1),
                            "type":  std_match.group(2).upper(),
                            "depth": int(std_match.group(3)),
                            "width": int(std_match.group(4))
                        })
                        continue

                    # --- Check 2: ASAP7 Banked Format ---
                    asap_match = asap7_regex.search(cell_name)
                    if asap_match:
                        rows  = int(asap_match.group(1))
                        banks = int(asap_match.group(2))
                        width = int(asap_match.group(3))
                        memories.append({
                            "name":  cell_name,
                            "type":  "1RW",  # ASAP7 'srambank' is typically Single Port (6T)
                            "depth": rows * banks, # Total Depth = Rows * Banks
                            "width": width
                        })
                        continue

                    # Debug output for first few misses
                    if cell_count <= 5:
                        print(f"[Debug] Found non-SRAM cell: {cell_name}")

    except FileNotFoundError:
        print(f"[Error] Library file not found: {lib_path}")
        sys.exit(1)

    print(f"[Auto-Mem] Scanned {cell_count} total cells.")
    print(f"[Auto-Mem] Identified {len(memories)} valid SRAM macros.")

    if len(memories) == 0 and cell_count > 0:
        print("[Error] Cells were found, but none matched the known SRAM naming conventions.")
        print("Standard: SRAM1RW1024x32")
        print("ASAP7:    srambank_128x4x32_...")
        print("Please check the '[Debug]' output above to see the actual cell names.")
        sys.exit(1)

    return memories

def generate_sp_wrapper(memories, output_dir):
    filename = os.path.join(output_dir, "VX_sp_ram_asic.v")
    # Filter for 1RW memories
    sp_mems = [m for m in memories if m['type'] == '1RW']

    # Sort for deterministic output
    sp_mems.sort(key=lambda x: (x['width'], x['depth']))

    with open(filename, 'w') as f:
        f.write("""// AUTOMATICALLY GENERATED BY gen_srams.py
(* keep_hierarchy = "yes" *)
module VX_sp_ram_asic #(
    parameter DATAW = 32,
    parameter SIZE  = 1024,
    parameter WRENW = 1,
    parameter ADDRW = $clog2(SIZE)
) (
    input  wire             clk,
    input  wire             reset,
    input  wire             read,
    input  wire             write,
    input  wire [WRENW-1:0] wren,
    input  wire [ADDRW-1:0] addr,
    input  wire [DATAW-1:0] wdata,
    output wire [DATAW-1:0] rdata
);
    wire write_n = ~write;
    wire read_n  = ~read;
    wire cs_n    = 1'b0;

    generate
""")

        first = True
        for m in sp_mems:
            prefix = "if" if first else "else if"
            first = False

            # Calculate physical address width required by the macro
            phy_addr_w = max(1, (m['depth'] - 1).bit_length())

            # Verilog string construction for padding logic
            pad_calc = f"{phy_addr_w} - ADDRW"
            pad_expr = "{ {" + pad_calc + "{1'b0}}, addr }"

            f.write(f"""
        {prefix} (DATAW == {m['width']} && SIZE <= {m['depth']}) begin : g_{m['name']}
            wire [{phy_addr_w-1}:0] internal_addr;

            // Address Padding: Match RTL address width to Physical Macro width
            assign internal_addr = (ADDRW < {phy_addr_w}) ?
                                   {pad_expr} :
                                   addr[{phy_addr_w-1}:0];

            {m['name']} u_mem (
                .{PINS['CLK']}  ( clk ),
                .{PINS['CS_N']} ( cs_n ),
                .{PINS['WE_N']} ( write_n ),
                .{PINS['OE_N']} ( read_n ),
                .{PINS['ADDR']} ( internal_addr ),
                .{PINS['DIN']}  ( wdata ),
                .{PINS['DOUT']} ( rdata )
            );
        end""")

        f.write("""
    endgenerate
endmodule
""")
    print(f"[Auto-Mem] Generated {filename}")

def generate_dp_wrapper(memories, output_dir):
    filename = os.path.join(output_dir, "VX_dp_ram_asic.v")
    dp_mems = [m for m in memories if m['type'] == '2RW']
    dp_mems.sort(key=lambda x: (x['width'], x['depth']))

    with open(filename, 'w') as f:
        f.write("""// AUTOMATICALLY GENERATED BY gen_srams.py
(* keep_hierarchy = "yes" *)
module VX_dp_ram_asic #(
    parameter DATAW = 32,
    parameter SIZE  = 1024,
    parameter WRENW = 1,
    parameter ADDRW = $clog2(SIZE)
) (
    input  wire             clk,
    input  wire             reset,
    input  wire             read,
    input  wire             write,
    input  wire [WRENW-1:0] wren,
    input  wire [ADDRW-1:0] waddr,
    input  wire [DATAW-1:0] wdata,
    input  wire [ADDRW-1:0] raddr,
    output wire [DATAW-1:0] rdata
);
    wire we_a_n = ~write;
    wire ce_b_n = ~read;

    generate
""")

        first = True
        for m in dp_mems:
            prefix = "if" if first else "else if"
            first = False
            phy_addr_w = max(1, (m['depth'] - 1).bit_length())

            pad_calc = f"{phy_addr_w} - ADDRW"
            pad_waddr = "{ {" + pad_calc + "{1'b0}}, waddr }"
            pad_raddr = "{ {" + pad_calc + "{1'b0}}, raddr }"

            f.write(f"""
        {prefix} (DATAW == {m['width']} && SIZE <= {m['depth']}) begin : g_{m['name']}
            wire [{phy_addr_w-1}:0] a1_addr;
            assign a1_addr = (ADDRW < {phy_addr_w}) ? {pad_waddr} : waddr[{phy_addr_w-1}:0];

            wire [{phy_addr_w-1}:0] a2_addr;
            assign a2_addr = (ADDRW < {phy_addr_w}) ? {pad_raddr} : raddr[{phy_addr_w-1}:0];

            {m['name']} u_mem (
                .CE1  ( clk ),
                .CSB1 ( 1'b0 ),
                .WEB1 ( we_a_n ),
                .OEB1 ( 1'b1 ),
                .A1   ( a1_addr ),
                .I1   ( wdata ),
                .O1   ( ),

                .CE2  ( clk ),
                .CSB2 ( 1'b0 ),
                .WEB2 ( 1'b1 ),
                .OEB2 ( ce_b_n ),
                .A2   ( a2_addr ),
                .I2   ( {m['width']}'b0 ),
                .O2   ( rdata )
            );
        end""")

        f.write("""
    endgenerate
endmodule
""")
    print(f"[Auto-Mem] Generated {filename}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("lib_file")
    parser.add_argument("out_dir")
    args = parser.parse_args()

    if not os.path.exists(args.out_dir):
        os.makedirs(args.out_dir)

    mems = parse_lib_file(args.lib_file)

    if not mems:
        print("[Error] No memories found. Check lib file or regex.")
        sys.exit(1)

    generate_sp_wrapper(mems, args.out_dir)
    generate_dp_wrapper(mems, args.out_dir)
